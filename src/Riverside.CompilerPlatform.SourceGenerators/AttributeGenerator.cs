#if CSHARP

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Riverside.Extensions.Accountability;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;

namespace Riverside.CompilerPlatform.SourceGenerators;

/// <summary>
/// Base class for attribute-based source generators.
/// </summary>
[Obsolete]
[NotMyCode]
public abstract class AttributeGenerator : IncrementalGenerator
{
	internal Dictionary<string, SyntaxTree>? _additionalSources = null;
	internal Diagnostic? _lastError = null;

	/// <summary>
	/// Gets additional syntax trees to include in the source generation.
	/// </summary>
	protected override Dictionary<string, SyntaxTree> AdditionalSources => _additionalSources ?? new Dictionary<string, SyntaxTree>();

	/// <inheritdoc/>
	public override List<SyntaxTree> Code { get; set; } = new();

	/// <summary>
	/// Process the compilation to find and generate code for relevant nodes.
	/// </summary>
	public abstract void ProcessCompilation(Compilation compilation, CancellationToken cancellationToken);

	/// <summary>
	/// Called when initializing the generator.
	/// </summary>
	/// <param name="context">The post-initialization context.</param>
	protected virtual void OnInitialize(IncrementalGeneratorPostInitializationContext context) { }

	/// <summary>
	/// Called before source generation begins.
	/// </summary>
	protected override void OnBeforeGeneration(Compilation compilation, CancellationToken cancellationToken)
	{
		// Clear previous results
		Code.Clear();
		_additionalSources = new Dictionary<string, SyntaxTree>();

		// Process the compilation
		try
		{
			ProcessCompilation(compilation, cancellationToken);
		}
		catch (Exception ex)
		{
			// Use the diagnostic helper from IncrementalGenerator
			var diagnostic = CreateDiagnostic(
				"GEN001",
				"Attribute Generator Error",
				$"An error occurred during attribute processing: {ex.Message}",
				DiagnosticSeverity.Error);

			if (!SuppressDiagnostics)
			{
				_lastError = diagnostic;
			}
		}
	}

	/// <summary>
	/// Creates a syntax tree for the given parameters using the appropriate language factory.
	/// </summary>
	/// <param name="symbol">The symbol for which the code is being generated.</param>
	/// <param name="namespaceName">The namespace name.</param>
	/// <param name="className">The class name.</param>
	/// <param name="memberCode">The member code to include in the class.</param>
	/// <returns>A syntax tree representing the generated code.</returns>
	protected SyntaxTree CreateLanguageSpecificSyntaxTree(ISymbol symbol, string namespaceName, string className, string memberCode)
	{
		return CreateCSharpSyntaxTree(symbol, namespaceName, className, memberCode);
	}

	/// <summary>
	/// Creates a C# syntax tree using the C# Roslyn API.
	/// </summary>
	/// <param name="symbol">The symbol for which the code is being generated.</param>
	/// <param name="namespaceName">The namespace name.</param>
	/// <param name="className">The class name.</param>
	/// <param name="memberCode">The member code to include in the class.</param>
	/// <returns>A syntax tree representing the generated code.</returns>
	protected SyntaxTree CreateCSharpSyntaxTree(ISymbol symbol, string namespaceName, string className, string memberCode)
	{
		using (var _ = new ParserOptionsScope())
		{
			// Using Microsoft.CodeAnalysis.CSharp and Microsoft.CodeAnalysis.CSharp.Syntax
			var namespaceDecl = SyntaxFactory.NamespaceDeclaration(
				SyntaxFactory.ParseName(namespaceName))
				.WithLeadingTrivia(SyntaxFactory.Comment("// <auto-generated>"),
					SyntaxFactory.Comment($"// This code was auto-generated by a tool for {symbol}."),
					SyntaxFactory.Comment("// </auto-generated>"),
					SyntaxFactory.Trivia(SyntaxFactory.NullableDirectiveTrivia(
						SyntaxFactory.Token(SyntaxKind.EnableKeyword), true)));

			// Create attribute for GeneratedCode
			var generatedAttribute = SyntaxFactory.AttributeList(
				SyntaxFactory.SingletonSeparatedList(
					SyntaxFactory.Attribute(
						SyntaxFactory.ParseName("global::System.CodeDom.Compiler.GeneratedCodeAttribute"),
						SyntaxFactory.AttributeArgumentList(
							SyntaxFactory.SeparatedList<AttributeArgumentSyntax>(
								new AttributeArgumentSyntax[] {
									SyntaxFactory.AttributeArgument(
										SyntaxFactory.LiteralExpression(
											SyntaxKind.StringLiteralExpression,
											SyntaxFactory.Literal("Riverside.CompilerPlatform.SourceGenerators"))),
									SyntaxFactory.AttributeArgument(
										SyntaxFactory.LiteralExpression(
											SyntaxKind.StringLiteralExpression,
											SyntaxFactory.Literal(FileVersionInfo.GetVersionInfo(
												System.Reflection.Assembly.GetExecutingAssembly().Location).ToString())))
								})))));

			// Create class declaration with the generated member code
			var classDecl = SyntaxFactory.ClassDeclaration(className)
				.WithModifiers(SyntaxFactory.TokenList(
					SyntaxFactory.Token(SyntaxKind.PartialKeyword)))
				.WithAttributeLists(SyntaxFactory.List(new[] { generatedAttribute }))
				.WithMembers(SyntaxFactory.List<MemberDeclarationSyntax>(
					new[] { SyntaxFactory.ParseMemberDeclaration(memberCode)! }));

			// Add the class to the namespace
			namespaceDecl = namespaceDecl.AddMembers(classDecl);

			// Create the compilation unit
			var compilationUnit = SyntaxFactory.CompilationUnit()
				.AddMembers(namespaceDecl)
				.NormalizeWhitespace();

			// Create the syntax tree
			return compilationUnit.SyntaxTree;
		}
	}

	/// <summary>
	/// Called after source generation completes.
	/// </summary>
	protected override void OnAfterGeneration(SourceProductionContext context)
	{
		// Report any diagnostic that was created during OnBeforeGeneration
		if (_lastError != null && !SuppressDiagnostics)
		{
			context.ReportDiagnostic(_lastError);
			_lastError = null;
		}

		base.OnAfterGeneration(context);
	}

	/// <summary>
	/// A scope for parser options that ensures proper disposal.
	/// </summary>
	protected class ParserOptionsScope : IDisposable
	{
		public ParserOptionsScope()
		{
			// Set up parser options
		}

		/// <inheritdoc/>
		public void Dispose()
		{
			// Clean up
		}
	}
}

#endif