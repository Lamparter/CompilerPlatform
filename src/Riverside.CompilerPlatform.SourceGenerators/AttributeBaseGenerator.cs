using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Riverside.CompilerPlatform.SourceGenerators.Extensions;
using Riverside.Extensions.Accountability;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace Riverside.CompilerPlatform.SourceGenerators;

/// <summary>
/// Base generator for processing attribute-based code generation with a single attribute type.
/// </summary>
/// <typeparam name="TAttribute">The attribute type to look for.</typeparam>
/// <typeparam name="TAttributeData">The wrapper type for attribute data.</typeparam>
/// <typeparam name="TSyntaxNode">The syntax node type to process.</typeparam>
/// <typeparam name="TSymbol">The symbol type to process.</typeparam>
[NotMyCode]
public abstract class AttributeGenerator<TAttribute, TAttributeData, TSyntaxNode, TSymbol> : IncrementalGenerator
	where TAttribute : Attribute
	where TSyntaxNode : MemberDeclarationSyntax
	where TSymbol : ISymbol
{
	private List<SyntaxTree> _code = new();
	private readonly string _fullAttributeName = typeof(TAttribute).FullName;

	/// <summary>
	/// Gets or sets whether to count subclasses of the attribute type.
	/// </summary>
	protected virtual bool CountAttributeSubclass => true;

	/// <summary>
	/// Gets or sets the generated code.
	/// </summary>
	public override List<SyntaxTree> Code
	{
		get => _code;
		set => _code = value;
	}

	/// <inheritdoc/>
	protected virtual void OnInitialize(IncrementalGeneratorPostInitializationContext context) { }

	/// <inheritdoc/>
	protected override void CustomizeInitialization(IncrementalGeneratorInitializationContext context)
	{
		// Register post-initialization output
		context.RegisterPostInitializationOutput(OnInitialize);

		// Set up the pipeline for processing nodes with attributes
		var attributeProvider = context.SyntaxProvider.CreateSyntaxProvider(
			(node, _) => node is TSyntaxNode syntaxNode && syntaxNode.AttributeLists.Count > 0,
			(genContext, cancellationToken) => ProcessNode(genContext, cancellationToken)
		);

		// Register output generation
		context.RegisterSourceOutput(
			attributeProvider.Where(result => result.HasOutput),
			(sourceContext, result) =>
			{
				if (result.HasOutput && result.FileName != null && result.Content != null)
					sourceContext.AddSource(result.FileName.Replace("?", "Nullable"), result.Content);
			});
	}

	/// <summary>
	/// Processes a syntax node to extract attribute data and generate code.
	/// </summary>
	private GeneratorResult ProcessNode(GeneratorSyntaxContext genContext, CancellationToken cancellationToken)
	{
		try
		{
			var syntaxNode = (TSyntaxNode)genContext.Node;

			// Get symbols for the node
			var symbols = GetSymbols(genContext, syntaxNode).ToArray();
			if (symbols.Length == 0)
				return new GeneratorResult(false);

			// Get the attribute class
			var attributeClass = genContext.SemanticModel.Compilation.GetTypeByMetadataName(_fullAttributeName);
			if (attributeClass == null)
				return new GeneratorResult(false);

			// Process attributes
			var attributes = (
				from attr in symbols[0].GetAttributes()
				where CountAttributeSubclass
					? attr.AttributeClass?.IsSubclassFrom(attributeClass) ?? false
					: attr.AttributeClass?.IsTheSameAs(attributeClass) ?? false
				let wrapper = TransformAttribute(attr, genContext.SemanticModel.Compilation)
				where wrapper != null
				select (Original: attr, Wrapper: wrapper)
			).ToArray();

			if (attributes.Length == 0)
				return new GeneratorResult(false);

			// Generate output for each symbol
			var outputs = new List<string>();
			foreach (var symbol in symbols)
			{
				string? output = OnPointVisit(genContext, syntaxNode, symbol, attributes);
				if (output != null)
					outputs.Add(output);
			}

			if (outputs.Count == 0)
				return new GeneratorResult(false);

			string joinedOutput = string.Join(Environment.NewLine + Environment.NewLine, outputs);

			// Generate the complete source file
			var containingClass = symbols[0] is INamedTypeSymbol nts ? nts : symbols[0].ContainingType;
			var genericParams = containingClass.TypeParameters;
			var classHeader = genericParams.Length == 0
				? containingClass.Name
				: $"{containingClass.Name}<{string.Join(", ", from x in genericParams select x.Name)}>";

			string fileName = $"{string.Join(" ", from x in symbols select x.ToString().Replace('<', '[').Replace('>', ']'))}.g.cs";
			string content = $$"""
				#nullable enable
				// Autogenerated for {{string.Join(", ", symbols)}}
					
				namespace {{containingClass.ContainingNamespace}}
				{
					partial class {{classHeader}}
					{
						// Original
						/*
						{{syntaxNode.ToString().Indent(2)}}
						*/
							
						{{joinedOutput.Indent(2)}}
					}
				}
				""";

			return new GeneratorResult(true, fileName, content);
		}
		catch (Exception ex)
		{
			// Handle exceptions by creating a diagnostic file
			string errorContent = $$"""
				/*
					Exception Occurred: {{ex.GetType().FullName}}
					Message: {{ex.Message}}
					Stack Trace:
						{{ex.StackTrace ?? "".Indent(2)}}
				*/
				""";

			return new GeneratorResult(true, $"Error_{Guid.NewGuid()}.g.cs", errorContent);
		}
	}

	/// <summary>
	/// Transforms an attribute to its data representation.
	/// </summary>
	/// <param name="attributeData">The attribute data to transform.</param>
	/// <param name="compilation">The current compilation.</param>
	/// <returns>The transformed attribute data.</returns>
	protected abstract TAttributeData? TransformAttribute(AttributeData attributeData, Compilation compilation);

	/// <summary>
	/// Called when visiting a symbol with attributes.
	/// </summary>
	/// <param name="genContext">The generator context.</param>
	/// <param name="syntaxNode">The syntax node being processed.</param>
	/// <param name="symbol">The symbol being processed.</param>
	/// <param name="attributeData">The attribute data.</param>
	/// <returns>The generated code, or null if no code should be generated.</returns>
	protected abstract string? OnPointVisit(GeneratorSyntaxContext genContext, TSyntaxNode syntaxNode, TSymbol symbol, (AttributeData Original, TAttributeData Wrapper)[] attributeData);

	/// <summary>
	/// Gets the symbols for a syntax node.
	/// </summary>
	/// <param name="genContext">The generator context.</param>
	/// <param name="syntaxNode">The syntax node being processed.</param>
	/// <returns>The symbols for the syntax node.</returns>
	protected virtual IEnumerable<TSymbol> GetSymbols(GeneratorSyntaxContext genContext, TSyntaxNode syntaxNode)
	{
		if (genContext.SemanticModel.GetDeclaredSymbol(syntaxNode) is TSymbol symbol)
			yield return symbol;
	}

	/// <summary>
	/// Represents the result of processing a node.
	/// </summary>
	private class GeneratorResult
	{
		/// <summary>
		/// Gets whether the result has output.
		/// </summary>
		public bool HasOutput { get; }

		/// <summary>
		/// Gets the file name for the output.
		/// </summary>
		public string? FileName { get; }

		/// <summary>
		/// Gets the content for the output.
		/// </summary>
		public string? Content { get; }

		/// <summary>
		/// Initializes a new instance of the <see cref="GeneratorResult"/> class.
		/// </summary>
		/// <param name="hasOutput">Whether the result has output.</param>
		/// <param name="fileName">The file name for the output.</param>
		/// <param name="content">The content for the output.</param>
		public GeneratorResult(bool hasOutput, string? fileName = null, string? content = null)
		{
			HasOutput = hasOutput;
			FileName = fileName;
			Content = content;
		}
	}
}

/// <summary>
/// Base generator for processing attribute-based code generation with two attribute types.
/// </summary>
/// <typeparam name="TAttribute1">The first attribute type to look for.</typeparam>
/// <typeparam name="TAttributeData1">The wrapper type for the first attribute data.</typeparam>
/// <typeparam name="TAttribute2">The second attribute type to look for.</typeparam>
/// <typeparam name="TAttributeData2">The wrapper type for the second attribute data.</typeparam>
/// <typeparam name="TSyntaxNode">The syntax node type to process.</typeparam>
/// <typeparam name="TSymbol">The symbol type to process.</typeparam>
public abstract class AttributeGenerator<TAttribute1, TAttributeData1, TAttribute2, TAttributeData2, TSyntaxNode, TSymbol> : IncrementalGenerator
	where TAttribute1 : Attribute
	where TAttributeData1 : struct
	where TAttribute2 : Attribute
	where TAttributeData2 : struct
	where TSyntaxNode : MemberDeclarationSyntax
	where TSymbol : ISymbol
{
	private List<SyntaxTree> _code = new List<SyntaxTree>();
	private readonly string _fullAttribute1Name = typeof(TAttribute1).FullName;
	private readonly string _fullAttribute2Name = typeof(TAttribute2).FullName;

	/// <summary>
	/// Gets or sets the generated code.
	/// </summary>
	public override List<SyntaxTree> Code
	{
		get => _code;
		set => _code = value;
	}

	/// <summary>
	/// Called when initializing the generator.
	/// </summary>
	/// <param name="context">The post-initialization context.</param>
	protected virtual void Initialize(IncrementalGeneratorPostInitializationContext context) { }

	/// <summary>
	/// Customizes the initialization pipeline.
	/// </summary>
	/// <param name="context">The initialization context.</param>
	protected override void CustomizeInitialization(IncrementalGeneratorInitializationContext context)
	{
		// Register post-initialization output
		context.RegisterPostInitializationOutput(Initialize);

		// Set up the pipeline for processing nodes with attributes
		var attributeProvider = context.SyntaxProvider.CreateSyntaxProvider(
			(node, _) => node is TSyntaxNode syntaxNode && syntaxNode.AttributeLists.Count > 0,
			(genContext, cancellationToken) => ProcessNode(genContext, cancellationToken)
		);

		// Register output generation
		context.RegisterSourceOutput(
			attributeProvider.Where(result => result.HasOutput),
			(sourceContext, result) =>
			{
				if (result.HasOutput && result.FileName != null && result.Content != null)
					sourceContext.AddSource(result.FileName, result.Content);
			});
	}

	/// <summary>
	/// Processes a syntax node to extract attribute data and generate code.
	/// </summary>
	private GeneratorResult ProcessNode(GeneratorSyntaxContext genContext, CancellationToken cancellationToken)
	{
		try
		{
			var syntaxNode = (TSyntaxNode)genContext.Node;

			// Get the symbol for the node
			var uncastedSymbol = genContext.SemanticModel.GetDeclaredSymbol(syntaxNode);
			if (uncastedSymbol is not TSymbol symbol)
				return new GeneratorResult(false);

			// Process attributes of the first type
			var attribute1s = (
				from attr in symbol.GetAttributes()
				where attr.AttributeClass?.ToDisplayString() == _fullAttribute1Name
				select TransformAttribute1(attr, genContext.SemanticModel.Compilation)
			).ToArray();

			// Process attributes of the second type
			var attribute2s = (
				from attr in symbol.GetAttributes()
				where attr.AttributeClass?.ToDisplayString() == _fullAttribute2Name
				select TransformAttribute2(attr, genContext.SemanticModel.Compilation)
			).ToArray();

			if (attribute1s.Length == 0 && attribute2s.Length == 0)
				return new GeneratorResult(false);

			// Generate output for the symbol
			string? output = OnPointVisit(genContext, syntaxNode, symbol, attribute1s, attribute2s);
			if (output == null)
				return new GeneratorResult(false);

			// Generate the complete source file
			var containingClass = symbol.ContainingType;
			var genericParams = containingClass.TypeParameters;
			var classHeader = genericParams.Length == 0
				? containingClass.Name
				: $"{containingClass.Name}<{string.Join(", ", from x in genericParams select x.Name)}>";

			string fileName = $"{symbol}.g.cs";
			string content = $$"""
				#nullable enable
				// Autogenerated for {{symbol}}
					
				namespace {{containingClass.ContainingNamespace}}
				{
					partial class {{classHeader}}
					{
						{{output.Indent(2)}}
					}
				}
				""";

			return new GeneratorResult(true, fileName, content);
		}
		catch (Exception ex)
		{
			// Handle exceptions by creating a diagnostic file
			string errorContent = $$"""
				/*
					Exception Occurred: {{ex.GetType().FullName}}
					Message: {{ex.Message}}
					Stack Trace:
						{{ex.StackTrace ?? "".Indent(2)}}
				*/
				""";

			return new GeneratorResult(true, $"Error_{Guid.NewGuid()}.g.cs", errorContent);
		}
	}

	/// <summary>
	/// Transforms an attribute of the first type to its data representation.
	/// </summary>
	/// <param name="attributeData">The attribute data to transform.</param>
	/// <param name="compilation">The current compilation.</param>
	/// <returns>The transformed attribute data.</returns>
	protected abstract TAttributeData1 TransformAttribute1(AttributeData attributeData, Compilation compilation);

	/// <summary>
	/// Transforms an attribute of the second type to its data representation.
	/// </summary>
	/// <param name="attributeData">The attribute data to transform.</param>
	/// <param name="compilation">The current compilation.</param>
	/// <returns>The transformed attribute data.</returns>
	protected abstract TAttributeData2 TransformAttribute2(AttributeData attributeData, Compilation compilation);

	/// <summary>
	/// Called when visiting a symbol with attributes.
	/// </summary>
	/// <param name="genContext">The generator context.</param>
	/// <param name="syntaxNode">The syntax node being processed.</param>
	/// <param name="symbol">The symbol being processed.</param>
	/// <param name="attribute1Data">The data for attributes of the first type.</param>
	/// <param name="attribute2Data">The data for attributes of the second type.</param>
	/// <returns>The generated code, or null if no code should be generated.</returns>
	protected abstract string? OnPointVisit(GeneratorSyntaxContext genContext, TSyntaxNode syntaxNode, TSymbol symbol, TAttributeData1[] attribute1Data, TAttributeData2[] attribute2Data);

	/// <summary>
	/// Represents the result of processing a node.
	/// </summary>
	private class GeneratorResult
	{
		/// <summary>
		/// Gets whether the result has output.
		/// </summary>
		public bool HasOutput { get; }

		/// <summary>
		/// Gets the file name for the output.
		/// </summary>
		public string? FileName { get; }

		/// <summary>
		/// Gets the content for the output.
		/// </summary>
		public string? Content { get; }

		/// <summary>
		/// Initializes a new instance of the <see cref="GeneratorResult"/> class.
		/// </summary>
		/// <param name="hasOutput">Whether the result has output.</param>
		/// <param name="fileName">The file name for the output.</param>
		/// <param name="content">The content for the output.</param>
		public GeneratorResult(bool hasOutput, string? fileName = null, string? content = null)
		{
			HasOutput = hasOutput;
			FileName = fileName;
			Content = content;
		}
	}
}
